<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dsp: dsp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dsp
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A Modern C++ digital signal processing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedsp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dsp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Constants and convenience functions for general signal processing tasks and 1D vector operations.  
<a href="namespacedsp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedsp_1_1convert"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1convert.html">convert</a></td></tr>
<tr class="memdesc:namespacedsp_1_1convert"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversions between various scales. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedsp_1_1fft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html">fft</a></td></tr>
<tr class="memdesc:namespacedsp_1_1fft"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transformations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedsp_1_1filter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1filter.html">filter</a></td></tr>
<tr class="memdesc:namespacedsp_1_1filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to apply and design digital filters. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedsp_1_1signals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1signals.html">signals</a></td></tr>
<tr class="memdesc:namespacedsp_1_1signals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions to generate various sampled test signals. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedsp_1_1special"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1special.html">special</a></td></tr>
<tr class="memdesc:namespacedsp_1_1special"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special functions (generally for library-internal use) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedsp_1_1window"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1window.html">window</a></td></tr>
<tr class="memdesc:namespacedsp_1_1window"><td class="mdescLeft">&#160;</td><td class="mdescRight">Window functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsp_1_1_signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a signal.  <a href="classdsp_1_1_signal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a880d958ba946cdac2fd8fd38ebfed7e0"><td class="memItemLeft" align="right" valign="top"><a id="a880d958ba946cdac2fd8fd38ebfed7e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>correlation_mode</b> = convolution_mode</td></tr>
<tr class="separator:a880d958ba946cdac2fd8fd38ebfed7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4ada11cd4c1c345d7a2be1bed40bae"><td class="memItemLeft" align="right" valign="top"><a id="a0c4ada11cd4c1c345d7a2be1bed40bae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>correlation_method</b> = convolution_method</td></tr>
<tr class="separator:a0c4ada11cd4c1c345d7a2be1bed40bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4e4ebc11d0bd80a1aa09a7796dcf91b6"><td class="memItemLeft" align="right" valign="top"><a id="a4e4ebc11d0bd80a1aa09a7796dcf91b6"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>convolution_mode</b> { <b>full</b>
, <b>valid</b>
, <b>same</b>
 }</td></tr>
<tr class="separator:a4e4ebc11d0bd80a1aa09a7796dcf91b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00a63d2b2f208a8ea97987898c67b2b"><td class="memItemLeft" align="right" valign="top"><a id="ab00a63d2b2f208a8ea97987898c67b2b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>convolution_method</b> { <b>automatic</b>
, <b>direct</b>
, <b>fft</b>
 }</td></tr>
<tr class="separator:ab00a63d2b2f208a8ea97987898c67b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac49d54afa2f2914214064372aa538495"><td class="memTemplParams" colspan="2"><a id="ac49d54afa2f2914214064372aa538495"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac49d54afa2f2914214064372aa538495"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ac49d54afa2f2914214064372aa538495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aeef1f9cbb591149d581cf6bde8642"><td class="memTemplParams" colspan="2"><a id="ae6aeef1f9cbb591149d581cf6bde8642"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae6aeef1f9cbb591149d581cf6bde8642"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ae6aeef1f9cbb591149d581cf6bde8642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3399ff111a4fe43e7d104aee429dd6"><td class="memTemplParams" colspan="2"><a id="a1c3399ff111a4fe43e7d104aee429dd6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c3399ff111a4fe43e7d104aee429dd6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a1c3399ff111a4fe43e7d104aee429dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd00d18c20869abef5ab0a2321496a8"><td class="memTemplParams" colspan="2"><a id="a1bd00d18c20869abef5ab0a2321496a8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1bd00d18c20869abef5ab0a2321496a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const T &amp;value)</td></tr>
<tr class="separator:a1bd00d18c20869abef5ab0a2321496a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46db348d549cd19e7a994afa049b6cd2"><td class="memTemplParams" colspan="2"><a id="a46db348d549cd19e7a994afa049b6cd2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a46db348d549cd19e7a994afa049b6cd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a46db348d549cd19e7a994afa049b6cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e8498033254a7a60e5d3683069eba1"><td class="memTemplParams" colspan="2"><a id="a20e8498033254a7a60e5d3683069eba1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a20e8498033254a7a60e5d3683069eba1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const T &amp;value)</td></tr>
<tr class="separator:a20e8498033254a7a60e5d3683069eba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0807af1a8dc47dd71039c9e7965bb"><td class="memTemplParams" colspan="2"><a id="aa3c0807af1a8dc47dd71039c9e7965bb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa3c0807af1a8dc47dd71039c9e7965bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aa3c0807af1a8dc47dd71039c9e7965bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8c4343a3f43bb4e65d4d5a7c78548b"><td class="memTemplParams" colspan="2"><a id="abe8c4343a3f43bb4e65d4d5a7c78548b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abe8c4343a3f43bb4e65d4d5a7c78548b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const T &amp;value)</td></tr>
<tr class="separator:abe8c4343a3f43bb4e65d4d5a7c78548b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77312e39e7887e6f3c9e311e974a913"><td class="memTemplParams" colspan="2"><a id="ab77312e39e7887e6f3c9e311e974a913"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab77312e39e7887e6f3c9e311e974a913"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ab77312e39e7887e6f3c9e311e974a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0ebdb902f2948847b4e678c152c6a3"><td class="memTemplParams" colspan="2"><a id="a3f0ebdb902f2948847b4e678c152c6a3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3f0ebdb902f2948847b4e678c152c6a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const T &amp;value)</td></tr>
<tr class="separator:a3f0ebdb902f2948847b4e678c152c6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25e1445c49802281d6be56496e4182"><td class="memTemplParams" colspan="2"><a id="aad25e1445c49802281d6be56496e4182"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aad25e1445c49802281d6be56496e4182"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aad25e1445c49802281d6be56496e4182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fab5e02eda0b4efaae6bbf38bcb892"><td class="memTemplParams" colspan="2"><a id="ab0fab5e02eda0b4efaae6bbf38bcb892"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab0fab5e02eda0b4efaae6bbf38bcb892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ab0fab5e02eda0b4efaae6bbf38bcb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d24443b944bca7795fbdcea54de0ba3"><td class="memTemplParams" colspan="2"><a id="a4d24443b944bca7795fbdcea54de0ba3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d24443b944bca7795fbdcea54de0ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a4d24443b944bca7795fbdcea54de0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e39c8a1d52dada481b0653048af687"><td class="memTemplParams" colspan="2"><a id="af8e39c8a1d52dada481b0653048af687"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af8e39c8a1d52dada481b0653048af687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, typename <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;::const_reference value)</td></tr>
<tr class="separator:af8e39c8a1d52dada481b0653048af687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc16d715d8a6bfc511b1dd5e7607c9b"><td class="memTemplParams" colspan="2"><a id="aefc16d715d8a6bfc511b1dd5e7607c9b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aefc16d715d8a6bfc511b1dd5e7607c9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aefc16d715d8a6bfc511b1dd5e7607c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f61b6b17771e8a70951b4228148e4b"><td class="memTemplParams" colspan="2"><a id="ae7f61b6b17771e8a70951b4228148e4b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae7f61b6b17771e8a70951b4228148e4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ae7f61b6b17771e8a70951b4228148e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776833ae64c7b5ba05dd96657ef2470e"><td class="memTemplParams" colspan="2"><a id="a776833ae64c7b5ba05dd96657ef2470e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a776833ae64c7b5ba05dd96657ef2470e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, typename <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;::const_reference value)</td></tr>
<tr class="separator:a776833ae64c7b5ba05dd96657ef2470e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1f893dca1094ffd8cfd3989a6d334d"><td class="memTemplParams" colspan="2"><a id="aee1f893dca1094ffd8cfd3989a6d334d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aee1f893dca1094ffd8cfd3989a6d334d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aee1f893dca1094ffd8cfd3989a6d334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30938925ca9280db69e0bf6cbeee4566"><td class="memTemplParams" colspan="2"><a id="a30938925ca9280db69e0bf6cbeee4566"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a30938925ca9280db69e0bf6cbeee4566"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a30938925ca9280db69e0bf6cbeee4566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5215955b942c28e7c70e310871910a6"><td class="memTemplParams" colspan="2"><a id="af5215955b942c28e7c70e310871910a6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af5215955b942c28e7c70e310871910a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, typename <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;::const_reference value)</td></tr>
<tr class="separator:af5215955b942c28e7c70e310871910a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4cce2b22c19c7c26db03e31edc89e5"><td class="memTemplParams" colspan="2"><a id="acb4cce2b22c19c7c26db03e31edc89e5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acb4cce2b22c19c7c26db03e31edc89e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:acb4cce2b22c19c7c26db03e31edc89e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d979b7519de57703a5c2f2feb72eb"><td class="memTemplParams" colspan="2"><a id="a517d979b7519de57703a5c2f2feb72eb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a517d979b7519de57703a5c2f2feb72eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a517d979b7519de57703a5c2f2feb72eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432e9148b4cd42d3004509e5710a6dea"><td class="memTemplParams" colspan="2"><a id="a432e9148b4cd42d3004509e5710a6dea"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a432e9148b4cd42d3004509e5710a6dea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;lhs, typename <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;::const_reference value)</td></tr>
<tr class="separator:a432e9148b4cd42d3004509e5710a6dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c782c2e5c688f668841d86e55893768"><td class="memTemplParams" colspan="2"><a id="a7c782c2e5c688f668841d86e55893768"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7c782c2e5c688f668841d86e55893768"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; signal, int exponent)</td></tr>
<tr class="separator:a7c782c2e5c688f668841d86e55893768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7237c5be52aad6a7105dfdaa51628742"><td class="memTemplParams" colspan="2"><a id="a7237c5be52aad6a7105dfdaa51628742"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7237c5be52aad6a7105dfdaa51628742"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pow</b> (std::vector&lt; T &gt; vec, int exponent)</td></tr>
<tr class="separator:a7237c5be52aad6a7105dfdaa51628742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daf2a67d3ae8f323dccffff80b66b4e"><td class="memTemplParams" colspan="2"><a id="a9daf2a67d3ae8f323dccffff80b66b4e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9daf2a67d3ae8f323dccffff80b66b4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; signal)</td></tr>
<tr class="separator:a9daf2a67d3ae8f323dccffff80b66b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7487e1bf42c1971f6f30acaf3d7cf35b"><td class="memTemplParams" colspan="2"><a id="a7487e1bf42c1971f6f30acaf3d7cf35b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7487e1bf42c1971f6f30acaf3d7cf35b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a7487e1bf42c1971f6f30acaf3d7cf35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61600b3f26920aeb9afeff40e864a1e6"><td class="memTemplParams" colspan="2"><a id="a61600b3f26920aeb9afeff40e864a1e6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a61600b3f26920aeb9afeff40e864a1e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="separator:a61600b3f26920aeb9afeff40e864a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fa67f8fd37c7fe350e523b102e3046"><td class="memTemplParams" colspan="2"><a id="a37fa67f8fd37c7fe350e523b102e3046"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a37fa67f8fd37c7fe350e523b102e3046"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; &amp;signal)</td></tr>
<tr class="separator:a37fa67f8fd37c7fe350e523b102e3046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb532b9d20ec1e768fd88e49b716065"><td class="memTemplParams" colspan="2"><a id="accb532b9d20ec1e768fd88e49b716065"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:accb532b9d20ec1e768fd88e49b716065"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; signal)</td></tr>
<tr class="separator:accb532b9d20ec1e768fd88e49b716065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097b96ea355e9565183ac242a383c404"><td class="memTemplParams" colspan="2"><a id="a097b96ea355e9565183ac242a383c404"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a097b96ea355e9565183ac242a383c404"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="separator:a097b96ea355e9565183ac242a383c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e811dd499d804420f91a1412397f735"><td class="memTemplParams" colspan="2"><a id="a2e811dd499d804420f91a1412397f735"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2e811dd499d804420f91a1412397f735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; signal)</td></tr>
<tr class="separator:a2e811dd499d804420f91a1412397f735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1475ccc3f98da4cdd514bf1462e97f"><td class="memItemLeft" align="right" valign="top"><a id="a9b1475ccc3f98da4cdd514bf1462e97f"></a>
std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>conj</b> (const std::vector&lt; float &gt; &amp;z)</td></tr>
<tr class="separator:a9b1475ccc3f98da4cdd514bf1462e97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee4906e1a369943aa50c3132847d6e0"><td class="memItemLeft" align="right" valign="top"><a id="a4ee4906e1a369943aa50c3132847d6e0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>conj</b> (const std::vector&lt; double &gt; &amp;z)</td></tr>
<tr class="separator:a4ee4906e1a369943aa50c3132847d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277582c9edeec5dc87ab45c62889f26e"><td class="memItemLeft" align="right" valign="top"><a id="a277582c9edeec5dc87ab45c62889f26e"></a>
std::vector&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>conj</b> (const std::vector&lt; long double &gt; &amp;z)</td></tr>
<tr class="separator:a277582c9edeec5dc87ab45c62889f26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90915d14fda7d97f3ca5d97d3d22944"><td class="memTemplParams" colspan="2"><a id="ad90915d14fda7d97f3ca5d97d3d22944"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad90915d14fda7d97f3ca5d97d3d22944"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arg</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; signal)</td></tr>
<tr class="separator:ad90915d14fda7d97f3ca5d97d3d22944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a8b7a2cce4364e0a2a779572bc6f8"><td class="memTemplParams" colspan="2"><a id="afb7a8b7a2cce4364e0a2a779572bc6f8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afb7a8b7a2cce4364e0a2a779572bc6f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm</b> (<a class="el" href="classdsp_1_1_signal.html">Signal</a>&lt; T &gt; signal)</td></tr>
<tr class="separator:afb7a8b7a2cce4364e0a2a779572bc6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0d14afef157ba0060fb89c92f96e0"><td class="memTemplParams" colspan="2"><a id="af3a0d14afef157ba0060fb89c92f96e0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af3a0d14afef157ba0060fb89c92f96e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>direct_convolution</b> (const std::vector&lt; T &gt; &amp;in1, const std::vector&lt; T &gt; &amp;in2, convolution_mode mode)</td></tr>
<tr class="separator:af3a0d14afef157ba0060fb89c92f96e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271d095b81b8b0a68871b9d11c980208"><td class="memTemplParams" colspan="2"><a id="a271d095b81b8b0a68871b9d11c980208"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a271d095b81b8b0a68871b9d11c980208"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a271d095b81b8b0a68871b9d11c980208">_reverse_and_conj</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a271d095b81b8b0a68871b9d11c980208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse and conjugate a vector. <br /></td></tr>
<tr class="separator:a271d095b81b8b0a68871b9d11c980208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cdd2fa60d4fd27ec9a72cde38811ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab0cdd2fa60d4fd27ec9a72cde38811ef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#ab0cdd2fa60d4fd27ec9a72cde38811ef">arange</a> (T start, T stop, T step=1)</td></tr>
<tr class="memdesc:ab0cdd2fa60d4fd27ec9a72cde38811ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return evenly spaced values within a given interval.  <a href="namespacedsp.html#ab0cdd2fa60d4fd27ec9a72cde38811ef">More...</a><br /></td></tr>
<tr class="separator:ab0cdd2fa60d4fd27ec9a72cde38811ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e593cd9ad8adf958be7d42c5643d27"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af0e593cd9ad8adf958be7d42c5643d27"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#af0e593cd9ad8adf958be7d42c5643d27">calculateEnergy</a> (typename std::vector&lt; T &gt;::iterator start, typename std::vector&lt; T &gt;::iterator end)</td></tr>
<tr class="memdesc:af0e593cd9ad8adf958be7d42c5643d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the energy of the passed range.  <a href="namespacedsp.html#af0e593cd9ad8adf958be7d42c5643d27">More...</a><br /></td></tr>
<tr class="separator:af0e593cd9ad8adf958be7d42c5643d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378f40c2851259db31cfa27f2cbe601f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a378f40c2851259db31cfa27f2cbe601f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a378f40c2851259db31cfa27f2cbe601f">calculateMeanPower</a> (typename std::vector&lt; T &gt;::iterator start, typename std::vector&lt; T &gt;::iterator end)</td></tr>
<tr class="memdesc:a378f40c2851259db31cfa27f2cbe601f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean power of the passed range.  <a href="namespacedsp.html#a378f40c2851259db31cfa27f2cbe601f">More...</a><br /></td></tr>
<tr class="separator:a378f40c2851259db31cfa27f2cbe601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aadad7161656d45fec883f1aba7c56"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a85aadad7161656d45fec883f1aba7c56"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a85aadad7161656d45fec883f1aba7c56">centered</a> (const std::vector&lt; T &gt; &amp;vec, size_t newSize)</td></tr>
<tr class="memdesc:a85aadad7161656d45fec883f1aba7c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center portion of a vector.  <a href="namespacedsp.html#a85aadad7161656d45fec883f1aba7c56">More...</a><br /></td></tr>
<tr class="separator:a85aadad7161656d45fec883f1aba7c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec532302b7a96119efb4702f1f3000"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a32ec532302b7a96119efb4702f1f3000"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a32ec532302b7a96119efb4702f1f3000">concatenate</a> (std::vector&lt; std::vector&lt; T &gt; * &gt; vectors)</td></tr>
<tr class="memdesc:a32ec532302b7a96119efb4702f1f3000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a sequence of vectors.  <a href="namespacedsp.html#a32ec532302b7a96119efb4702f1f3000">More...</a><br /></td></tr>
<tr class="separator:a32ec532302b7a96119efb4702f1f3000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014ebcddb5a8e374054024212fa30eac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a014ebcddb5a8e374054024212fa30eac"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; convolution_method, std::map&lt; convolution_method, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a014ebcddb5a8e374054024212fa30eac">choose_conv_method</a> (const std::vector&lt; T &gt; &amp;in1, const std::vector&lt; T &gt; &amp;in2, convolution_mode mode=convolution_mode::full, bool measure=false)</td></tr>
<tr class="memdesc:a014ebcddb5a8e374054024212fa30eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the fastest convolution/correlation method. This primarily exists to be called during the method = 'auto' option in convolve and correlate. It can also be used to determine the value of method for many different convolutions of the same length. In addition, it supports timing the convolution to adapt the value of method to a particular set of inputs and/or hardware.  <a href="namespacedsp.html#a014ebcddb5a8e374054024212fa30eac">More...</a><br /></td></tr>
<tr class="separator:a014ebcddb5a8e374054024212fa30eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c98d9b699a7b705797c56afb00df53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a83c98d9b699a7b705797c56afb00df53"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a83c98d9b699a7b705797c56afb00df53">convolve</a> (const std::vector&lt; T &gt; &amp;in1, const std::vector&lt; T &gt; &amp;in2, convolution_mode mode=convolution_mode::full, convolution_method method=convolution_method::automatic)</td></tr>
<tr class="memdesc:a83c98d9b699a7b705797c56afb00df53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve two N-dimensional arrays.  <a href="namespacedsp.html#a83c98d9b699a7b705797c56afb00df53">More...</a><br /></td></tr>
<tr class="separator:a83c98d9b699a7b705797c56afb00df53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997c174f04e83c492ef8637b88c714bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a997c174f04e83c492ef8637b88c714bf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a997c174f04e83c492ef8637b88c714bf">correlate</a> (const std::vector&lt; T &gt; &amp;in1, const std::vector&lt; T &gt; &amp;in2, correlation_mode mode=correlation_mode::full, correlation_method method=correlation_method::automatic)</td></tr>
<tr class="memdesc:a997c174f04e83c492ef8637b88c714bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-correlate two vectors.  <a href="namespacedsp.html#a997c174f04e83c492ef8637b88c714bf">More...</a><br /></td></tr>
<tr class="separator:a997c174f04e83c492ef8637b88c714bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad015f85c579767ffebdded0b8d149d89"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad015f85c579767ffebdded0b8d149d89"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#ad015f85c579767ffebdded0b8d149d89">autocorrelate</a> (const std::vector&lt; T &gt; &amp;in, correlation_mode mode=correlation_mode::full, correlation_method method=correlation_method::automatic)</td></tr>
<tr class="memdesc:ad015f85c579767ffebdded0b8d149d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-correlate a vector with itself.  <a href="namespacedsp.html#ad015f85c579767ffebdded0b8d149d89">More...</a><br /></td></tr>
<tr class="separator:ad015f85c579767ffebdded0b8d149d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32d93264393a07d8b3844eed53e9c3"><td class="memTemplParams" colspan="2">template&lt;class T , class Pred &gt; </td></tr>
<tr class="memitem:abe32d93264393a07d8b3844eed53e9c3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#abe32d93264393a07d8b3844eed53e9c3">extract</a> (Pred condition, const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:abe32d93264393a07d8b3844eed53e9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elements of a vector that satisfy some condition.  <a href="namespacedsp.html#abe32d93264393a07d8b3844eed53e9c3">More...</a><br /></td></tr>
<tr class="separator:abe32d93264393a07d8b3844eed53e9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529bdda638f4dab2d413faac208a65b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a529bdda638f4dab2d413faac208a65b9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a529bdda638f4dab2d413faac208a65b9">linspace</a> (T start, T stop, size_t num=50, bool endpoint=true)</td></tr>
<tr class="memdesc:a529bdda638f4dab2d413faac208a65b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return evenly spaced numbers over a specified interval.  <a href="namespacedsp.html#a529bdda638f4dab2d413faac208a65b9">More...</a><br /></td></tr>
<tr class="separator:a529bdda638f4dab2d413faac208a65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd26b23f1e5d64efffe0a893c7c91c5"><td class="memTemplParams" colspan="2"><a id="aedd26b23f1e5d64efffe0a893c7c91c5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedd26b23f1e5d64efffe0a893c7c91c5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp.html#aedd26b23f1e5d64efffe0a893c7c91c5">mod</a> (T x1, T x2)</td></tr>
<tr class="memdesc:aedd26b23f1e5d64efffe0a893c7c91c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return modulus (which is not the same as the remainder for signed values) <br /></td></tr>
<tr class="separator:aedd26b23f1e5d64efffe0a893c7c91c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11078b40d98913e2a044205d64c1a1a7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp.html#a11078b40d98913e2a044205d64c1a1a7">nextpow2</a> (unsigned n)</td></tr>
<tr class="memdesc:a11078b40d98913e2a044205d64c1a1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next-largest power of two k so that n &lt;= 2^k.  <a href="namespacedsp.html#a11078b40d98913e2a044205d64c1a1a7">More...</a><br /></td></tr>
<tr class="separator:a11078b40d98913e2a044205d64c1a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aab1a36a5c74fdc52ccdafef6511c2eb2"><td class="memItemLeft" align="right" valign="top"><a id="aab1a36a5c74fdc52ccdafef6511c2eb2"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>pi</b> = 3.14159265358979311600</td></tr>
<tr class="separator:aab1a36a5c74fdc52ccdafef6511c2eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Constants and convenience functions for general signal processing tasks and 1D vector operations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab0cdd2fa60d4fd27ec9a72cde38811ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cdd2fa60d4fd27ec9a72cde38811ef">&#9670;&nbsp;</a></span>arange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dsp::arange </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return evenly spaced values within a given interval. </p>
<p>Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of interval. The interval includes this value. </td></tr>
    <tr><td class="paramname">stop</td><td>End of interval. The interval does not include this value. </td></tr>
    <tr><td class="paramname">step</td><td>Spacing between values. For any output out, this is the distance between two adjacent values, out[i+1] - out[i]. The default step size is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of evenly spaced values </dd></dl>

</div>
</div>
<a id="ad015f85c579767ffebdded0b8d149d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad015f85c579767ffebdded0b8d149d89">&#9670;&nbsp;</a></span>autocorrelate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dsp::autocorrelate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">correlation_mode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>correlation_mode::full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">correlation_method&#160;</td>
          <td class="paramname"><em>method</em> = <code>correlation_method::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto-correlate a vector with itself. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input vector </td></tr>
    <tr><td class="paramname">mode</td><td>An enum indicating the size of the output: full: The output is the full discrete linear auto-correlation of the inputs. (Default) valid: The output consists only of those elements that do not rely on the zero-padding. In ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. same: The output is the same size as in1, centered with respect to the ‘full’ output. </td></tr>
    <tr><td class="paramname">method</td><td>An enum indicating which method to use to calculate the correlation. direct: The correlation is determined directly from sums, the definition of correlation. fft: The Fast Fourier Transform is used to perform the correlation more quickly. automatic: Automatically chooses direct or fft method based on an estimate of which is faster (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing a subset of the discrete linear auto-correlation of in. </dd></dl>

</div>
</div>
<a id="af0e593cd9ad8adf958be7d42c5643d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e593cd9ad8adf958be7d42c5643d27">&#9670;&nbsp;</a></span>calculateEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dsp::calculateEnergy </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; T &gt;::iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T &gt;::iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the energy of the passed range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Iterator pointing to the start of the range (e.g. my_signal.begin()) </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the range (e.g. my_signal.end()) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The energy of the range (sum of the squared samples in range) </dd></dl>

</div>
</div>
<a id="a378f40c2851259db31cfa27f2cbe601f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378f40c2851259db31cfa27f2cbe601f">&#9670;&nbsp;</a></span>calculateMeanPower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T dsp::calculateMeanPower </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; T &gt;::iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T &gt;::iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mean power of the passed range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Iterator pointing to the start of the range (e.g. my_signal.begin()) </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the range (e.g. my_signal.end()) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean power of the range (energy divided by length) </dd></dl>

</div>
</div>
<a id="a85aadad7161656d45fec883f1aba7c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85aadad7161656d45fec883f1aba7c56">&#9670;&nbsp;</a></span>centered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; dsp::centered </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the center portion of a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Input vector </td></tr>
    <tr><td class="paramname">newSize</td><td>Length of the extracted, centered portion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Centered portion of the vector </dd></dl>

</div>
</div>
<a id="a014ebcddb5a8e374054024212fa30eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014ebcddb5a8e374054024212fa30eac">&#9670;&nbsp;</a></span>choose_conv_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;convolution_method, std::map&lt;convolution_method, double&gt; &gt; dsp::choose_conv_method </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">convolution_mode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>convolution_mode::full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>measure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the fastest convolution/correlation method. This primarily exists to be called during the method = 'auto' option in convolve and correlate. It can also be used to determine the value of method for many different convolutions of the same length. In addition, it supports timing the convolution to adapt the value of method to a particular set of inputs and/or hardware. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in1</td><td>The first argument passed into the convolution function. </td></tr>
    <tr><td class="paramname">in2</td><td>The second argument passed into the convolution function. </td></tr>
    <tr><td class="paramname">mode</td><td>An enum indicating the size of the output: full: The output is the full discrete linear cross-correlation of the inputs. (Default) valid: The output consists only of those elements that do not rely on the zero-padding. In ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. same: The output is the same size as in1, centered with respect to the ‘full’ output. </td></tr>
    <tr><td class="paramname">measure</td><td>If true, run and time the convolution of in1 and in2 with both methods and return the fastest. If false (default), predict the fastest method using precomputed values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing an enum indicating which convolution method is fastest, either ‘direct’ or ‘fft’, and a map containing the times (in seconds) needed for each method. This map is only non-empty if measure=true. </dd></dl>

</div>
</div>
<a id="a32ec532302b7a96119efb4702f1f3000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ec532302b7a96119efb4702f1f3000">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dsp::concatenate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>vectors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a sequence of vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectors</td><td>Vector containing references to the vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated vector. <br  />
 </dd></dl>

</div>
</div>
<a id="a83c98d9b699a7b705797c56afb00df53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c98d9b699a7b705797c56afb00df53">&#9670;&nbsp;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; dsp::convolve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">convolution_mode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>convolution_mode::full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">convolution_method&#160;</td>
          <td class="paramname"><em>method</em> = <code>convolution_method::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve two N-dimensional arrays. </p>
<p>Convolve in1and in2, with the output size determined by the mode argument. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in1</td><td>First input </td></tr>
    <tr><td class="paramname">in2</td><td>Second input full: The output is the full discrete convolution of the inputs. (Default) valid: The output consists only of those elements that do not rely on the zero-padding. In ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. same: The output is the same size as in1, centered with respect to the ‘full’ output. </td></tr>
    <tr><td class="paramname">method</td><td>An enum indicating which method to use to calculate the convolution. direct: The correlation is determined directly from sums, the definition of correlation. fft: The Fast Fourier Transform is used to perform the correlation more quickly. automatic: Automatically chooses direct or fft method based on an estimate of which is faster (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing a subset of the discrete convolution of in1 with in2. </dd></dl>

</div>
</div>
<a id="a997c174f04e83c492ef8637b88c714bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997c174f04e83c492ef8637b88c714bf">&#9670;&nbsp;</a></span>correlate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; dsp::correlate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">correlation_mode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>correlation_mode::full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">correlation_method&#160;</td>
          <td class="paramname"><em>method</em> = <code>correlation_method::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cross-correlate two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in1</td><td>First input </td></tr>
    <tr><td class="paramname">in2</td><td>Second input </td></tr>
    <tr><td class="paramname">mode</td><td>An enum indicating the size of the output: full: The output is the full discrete linear cross-correlation of the inputs. (Default) valid: The output consists only of those elements that do not rely on the zero-padding. In ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. same: The output is the same size as in1, centered with respect to the ‘full’ output. </td></tr>
    <tr><td class="paramname">method</td><td>An enum indicating which method to use to calculate the correlation. direct: The correlation is determined directly from sums, the definition of correlation. fft: The Fast Fourier Transform is used to perform the correlation more quickly. automatic: Automatically chooses direct or fft method based on an estimate of which is faster (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing a subset of the discrete linear cross-correlation of in1 with in2. </dd></dl>

</div>
</div>
<a id="abe32d93264393a07d8b3844eed53e9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe32d93264393a07d8b3844eed53e9c3">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dsp::extract </td>
          <td>(</td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elements of a vector that satisfy some condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">Pred</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>A predicate which if true indicates the elements of vec to extract. </td></tr>
    <tr><td class="paramname">vec</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of values from vec where condition is true. </dd></dl>

</div>
</div>
<a id="a529bdda638f4dab2d413faac208a65b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529bdda638f4dab2d413faac208a65b9">&#9670;&nbsp;</a></span>linspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; dsp::linspace </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return evenly spaced numbers over a specified interval. </p>
<p>Returns N evenly spaced samples, calculated over the interval[start, stop].</p>
<p>The endpoint of the interval can optionally be excluded. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the values in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting value of the sequence. </td></tr>
    <tr><td class="paramname">stop</td><td>The end value of the sequence, unless endpoint is set to False. In that case, the sequence consists of all but the last of num + 1 evenly spaced samples, so that stop is excluded. Note that the step size changes when endpoint is False. </td></tr>
    <tr><td class="paramname">num</td><td>Number of samples to generate. Default is 50. </td></tr>
    <tr><td class="paramname">endpoint</td><td>If True, stop is the last sample. Otherwise, it is not included. Default is True. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of evenly spaced numbers over the specified interval </dd></dl>

</div>
</div>
<a id="a11078b40d98913e2a044205d64c1a1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11078b40d98913e2a044205d64c1a1a7">&#9670;&nbsp;</a></span>nextpow2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dsp::nextpow2 </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next-largest power of two k so that n &lt;= 2^k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of which find the next-largest power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next-largest power of two so that n &lt;= 2^k <br  />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedsp.html">dsp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
