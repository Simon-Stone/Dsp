<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dsp: dsp::fft Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dsp
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A Modern C++ digital signal processing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedsp_1_1fft.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dsp::fft Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fast Fourier Transformations.  
<a href="namespacedsp_1_1fft.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aadeffdb34ec53320437b1c6dd1354915"><td class="memItemLeft" align="right" valign="top"><a id="aadeffdb34ec53320437b1c6dd1354915"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> { <b>backward</b>
, <b>ortho</b>
, <b>forward</b>
 }</td></tr>
<tr class="memdesc:aadeffdb34ec53320437b1c6dd1354915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization mode for the various transforms: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. <br /></td></tr>
<tr class="separator:aadeffdb34ec53320437b1c6dd1354915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fef2564f82f5eb8ea2d5c9909fb2ba4"><td class="memItemLeft" align="right" valign="top"><a id="a4fef2564f82f5eb8ea2d5c9909fb2ba4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> { <b>automatic</b>
, <b>simple</b>
, <b>fftw</b>
 }</td></tr>
<tr class="memdesc:a4fef2564f82f5eb8ea2d5c9909fb2ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend choices for performing the actual transformations. <br /></td></tr>
<tr class="separator:a4fef2564f82f5eb8ea2d5c9909fb2ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1e8b2af8a1d75b65f349492f865631d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae1e8b2af8a1d75b65f349492f865631d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#ae1e8b2af8a1d75b65f349492f865631d">cfft</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;x, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=NormalizationMode::backward, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:ae1e8b2af8a1d75b65f349492f865631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1-D discrete Fourier Transform.  <a href="namespacedsp_1_1fft.html#ae1e8b2af8a1d75b65f349492f865631d">More...</a><br /></td></tr>
<tr class="separator:ae1e8b2af8a1d75b65f349492f865631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08ff97f7230431add10365d4c8ee820"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab08ff97f7230431add10365d4c8ee820"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#ab08ff97f7230431add10365d4c8ee820">icfft</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;X, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=NormalizationMode::backward, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:ab08ff97f7230431add10365d4c8ee820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1-D inverse discrete Fourier Transform.  <a href="namespacedsp_1_1fft.html#ab08ff97f7230431add10365d4c8ee820">More...</a><br /></td></tr>
<tr class="separator:ab08ff97f7230431add10365d4c8ee820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd22f50ee56c93d30935f0077361450"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7fd22f50ee56c93d30935f0077361450"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a7fd22f50ee56c93d30935f0077361450">rfft</a> (const std::vector&lt; T &gt; &amp;x, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=NormalizationMode::backward, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:a7fd22f50ee56c93d30935f0077361450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1-D discrete Fourier Transform for real input.  <a href="namespacedsp_1_1fft.html#a7fd22f50ee56c93d30935f0077361450">More...</a><br /></td></tr>
<tr class="separator:a7fd22f50ee56c93d30935f0077361450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15fe330f8a7a2d98f10ceeada2a7df5"><td class="memTemplParams" colspan="2"><a id="ab15fe330f8a7a2d98f10ceeada2a7df5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab15fe330f8a7a2d98f10ceeada2a7df5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#ab15fe330f8a7a2d98f10ceeada2a7df5">fft</a> (const std::vector&lt; T &gt; &amp;x, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=NormalizationMode::backward, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:ab15fe330f8a7a2d98f10ceeada2a7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for rfft. <br /></td></tr>
<tr class="separator:ab15fe330f8a7a2d98f10ceeada2a7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9c8542f82a31aa5745f9b885d8fdbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3b9c8542f82a31aa5745f9b885d8fdbc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a3b9c8542f82a31aa5745f9b885d8fdbc">irfft</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;X, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=NormalizationMode::backward, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:a3b9c8542f82a31aa5745f9b885d8fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of rfft.  <a href="namespacedsp_1_1fft.html#a3b9c8542f82a31aa5745f9b885d8fdbc">More...</a><br /></td></tr>
<tr class="separator:a3b9c8542f82a31aa5745f9b885d8fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce897c0dfc4bedf80452b2a763769b1"><td class="memTemplParams" colspan="2"><a id="a7ce897c0dfc4bedf80452b2a763769b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ce897c0dfc4bedf80452b2a763769b1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a7ce897c0dfc4bedf80452b2a763769b1">ifft</a> (const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;X, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=NormalizationMode::backward, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:a7ce897c0dfc4bedf80452b2a763769b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="namespacedsp_1_1fft.html#a3b9c8542f82a31aa5745f9b885d8fdbc" title="Computes the inverse of rfft.">irfft()</a> <br /></td></tr>
<tr class="separator:a7ce897c0dfc4bedf80452b2a763769b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299e141eb0a89c1b69d0c1571c22222a"><td class="memTemplParams" colspan="2"><a id="a299e141eb0a89c1b69d0c1571c22222a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a299e141eb0a89c1b69d0c1571c22222a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>logSquaredMagnitudeSpectrum</b> (const std::vector&lt; T &gt; &amp;signal, int N_fft, double relativeCutoff)</td></tr>
<tr class="separator:a299e141eb0a89c1b69d0c1571c22222a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167c9e606b663c22f0f39e2296d1377b"><td class="memTemplParams" colspan="2"><a id="a167c9e606b663c22f0f39e2296d1377b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a167c9e606b663c22f0f39e2296d1377b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a167c9e606b663c22f0f39e2296d1377b">fftconvolution</a> (const std::vector&lt; T &gt; &amp;volume, const std::vector&lt; T &gt; &amp;kernel, convolution_mode <a class="el" href="namespacedsp.html#a1d4932cf0fd90a0ecde3b2deffeb740c">mode</a>=convolution_mode::valid)</td></tr>
<tr class="memdesc:a167c9e606b663c22f0f39e2296d1377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast convolution using the FFT. <br /></td></tr>
<tr class="separator:a167c9e606b663c22f0f39e2296d1377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1165887d30389fb6565efc597be66ce1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1165887d30389fb6565efc597be66ce1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a1165887d30389fb6565efc597be66ce1">spectrogram</a> (const std::vector&lt; T &gt; &amp;signal, unsigned frameLength, double overlap_pct=0.5, int samplingRate=-1, double relativeCutoff=0.5, <a class="el" href="namespacedsp_1_1window.html#a1cc0dcec4aa9e12640771bdf41f695b8">window::type</a> windowType=window::type::hamming)</td></tr>
<tr class="memdesc:a1165887d30389fb6565efc597be66ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a spectrogram of the passed signal.  <a href="namespacedsp_1_1fft.html#a1165887d30389fb6565efc597be66ce1">More...</a><br /></td></tr>
<tr class="separator:a1165887d30389fb6565efc597be66ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fast Fourier Transformations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae1e8b2af8a1d75b65f349492f865631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e8b2af8a1d75b65f349492f865631d">&#9670;&nbsp;</a></span>cfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; T &gt; &gt; dsp::fft::cfft </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 1-D discrete Fourier Transform. </p>
<p>This function computes the 1-D n-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform(FFT) algorithm for complex input signals. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the complex values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Complex input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="ab08ff97f7230431add10365d4c8ee820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08ff97f7230431add10365d4c8ee820">&#9670;&nbsp;</a></span>icfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; T &gt; &gt; dsp::fft::icfft </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 1-D inverse discrete Fourier Transform. </p>
<p>This function computes the inverse of the 1-D n-point discrete Fourier transform computed by fft. In other words, ifft(fft(x)) == x to within numerical accuracy. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the complex values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Complex input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="a3b9c8542f82a31aa5745f9b885d8fdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9c8542f82a31aa5745f9b885d8fdbc">&#9670;&nbsp;</a></span>irfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; dsp::fft::irfft </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of rfft. </p>
<p>This function computes the inverse of the 1-D n-point discrete Fourier Transform of real input computed by rfft. In other words, irfft(rfft(x), x.size()) == x to within numerical accuracy. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the complex values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Complex input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The backward-transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="a7fd22f50ee56c93d30935f0077361450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd22f50ee56c93d30935f0077361450">&#9670;&nbsp;</a></span>rfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; T &gt; &gt; dsp::fft::rfft </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 1-D discrete Fourier Transform for real input. </p>
<p>This function computes the 1-D n-point discrete Fourier Transform (DFT) of a real-valued vector by means of an efficient algorithm called the Fast Fourier Transform (FFT). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the real values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Real input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. <br  />
 </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The forward-transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="a1165887d30389fb6565efc597be66ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1165887d30389fb6565efc597be66ce1">&#9670;&nbsp;</a></span>spectrogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; dsp::fft::spectrogram </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>frameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>overlap_pct</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplingRate</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relativeCutoff</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1window.html#a1cc0dcec4aa9e12640771bdf41f695b8">window::type</a>&#160;</td>
          <td class="paramname"><em>windowType</em> = <code>window::type::hamming</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a spectrogram of the passed signal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the signal's samples </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td><a class="el" href="classdsp_1_1_signal.html" title="This class represents a scalar signal.">Signal</a> to analyze </td></tr>
    <tr><td class="paramname">frameLength</td><td>Length of each frame </td></tr>
    <tr><td class="paramname">overlap_pct</td><td>Relative overlap between two frames (e.g., 0.75 for 75% overlap) </td></tr>
    <tr><td class="paramname">samplingRate</td><td>Sampling rate in Hz. Can be -1 to use normalized frequencies. </td></tr>
    <tr><td class="paramname">relativeCutoff</td><td>How much of the spectrum to calculate. Default 0.5 to discard mirrored part of the spectrum (assuming real input). </td></tr>
    <tr><td class="paramname">windowType</td><td>Type of the window to use to window each frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the log-squared-magnitude spectrum of each windowed frame of the signal. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedsp.html">dsp</a></li><li class="navelem"><a class="el" href="namespacedsp_1_1fft.html">fft</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
