<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dsp: dsp::fft Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dsp
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A Modern C++ digital signal processing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedsp_1_1fft.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dsp::fft Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fast Fourier Transformations.  
<a href="namespacedsp_1_1fft.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aadeffdb34ec53320437b1c6dd1354915"><td class="memItemLeft" align="right" valign="top"><a id="aadeffdb34ec53320437b1c6dd1354915"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> { <b>backward</b>
, <b>ortho</b>
, <b>forward</b>
 }</td></tr>
<tr class="memdesc:aadeffdb34ec53320437b1c6dd1354915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization mode for the various transforms: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. <br /></td></tr>
<tr class="separator:aadeffdb34ec53320437b1c6dd1354915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fef2564f82f5eb8ea2d5c9909fb2ba4"><td class="memItemLeft" align="right" valign="top"><a id="a4fef2564f82f5eb8ea2d5c9909fb2ba4"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> { <b>automatic</b>
, <b>simple</b>
, <b>fftw</b>
 }</td></tr>
<tr class="memdesc:a4fef2564f82f5eb8ea2d5c9909fb2ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend choices for performing the actual transformations. <br /></td></tr>
<tr class="separator:a4fef2564f82f5eb8ea2d5c9909fb2ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acd4596e9d5c9bd56e8b10baf64c78b3c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acd4596e9d5c9bd56e8b10baf64c78b3c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#acd4596e9d5c9bd56e8b10baf64c78b3c">cfft</a> (std::vector&lt; std::complex&lt; T &gt;&gt; &amp;x, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> mode=NormalizationMode::backward, bool overwrite_x=false, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:acd4596e9d5c9bd56e8b10baf64c78b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1-D discrete Fourier Transform.  <a href="namespacedsp_1_1fft.html#acd4596e9d5c9bd56e8b10baf64c78b3c">More...</a><br /></td></tr>
<tr class="separator:acd4596e9d5c9bd56e8b10baf64c78b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b408972cb96b687bd207fe14b341df"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40b408972cb96b687bd207fe14b341df"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a40b408972cb96b687bd207fe14b341df">icfft</a> (std::vector&lt; std::complex&lt; T &gt;&gt; &amp;X, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> mode=NormalizationMode::backward, bool overwrite_X=false, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:a40b408972cb96b687bd207fe14b341df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1-D inverse discrete Fourier Transform.  <a href="namespacedsp_1_1fft.html#a40b408972cb96b687bd207fe14b341df">More...</a><br /></td></tr>
<tr class="separator:a40b408972cb96b687bd207fe14b341df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054d4669893e32e3b3162ca4e661ffca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a054d4669893e32e3b3162ca4e661ffca"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a054d4669893e32e3b3162ca4e661ffca">rfft</a> (std::vector&lt; T &gt; &amp;x, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> mode=NormalizationMode::backward, bool overwrite_x=false, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:a054d4669893e32e3b3162ca4e661ffca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 1-D discrete Fourier Transform for real input.  <a href="namespacedsp_1_1fft.html#a054d4669893e32e3b3162ca4e661ffca">More...</a><br /></td></tr>
<tr class="separator:a054d4669893e32e3b3162ca4e661ffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9250d054380713cb0fdfccd14185732"><td class="memTemplParams" colspan="2"><a id="ac9250d054380713cb0fdfccd14185732"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac9250d054380713cb0fdfccd14185732"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#ac9250d054380713cb0fdfccd14185732">fft</a> (std::vector&lt; T &gt; &amp;x, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> mode=NormalizationMode::backward, bool overwrite_x=false, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:ac9250d054380713cb0fdfccd14185732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for rfft. <br /></td></tr>
<tr class="separator:ac9250d054380713cb0fdfccd14185732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f6db704ad42fa5b125b8cde90f2603"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac9f6db704ad42fa5b125b8cde90f2603"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#ac9f6db704ad42fa5b125b8cde90f2603">irfft</a> (std::vector&lt; std::complex&lt; T &gt;&gt; &amp;X, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> mode=NormalizationMode::backward, bool overwrite_X=false, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:ac9f6db704ad42fa5b125b8cde90f2603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of rfft.  <a href="namespacedsp_1_1fft.html#ac9f6db704ad42fa5b125b8cde90f2603">More...</a><br /></td></tr>
<tr class="separator:ac9f6db704ad42fa5b125b8cde90f2603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56643f8c6484395b2a70f0a4312476a"><td class="memTemplParams" colspan="2"><a id="af56643f8c6484395b2a70f0a4312476a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af56643f8c6484395b2a70f0a4312476a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#af56643f8c6484395b2a70f0a4312476a">ifft</a> (std::vector&lt; std::complex&lt; T &gt;&gt; &amp;X, unsigned n=0, <a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a> mode=NormalizationMode::backward, bool overwrite_X=false, <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a> <a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>=backend::automatic)</td></tr>
<tr class="memdesc:af56643f8c6484395b2a70f0a4312476a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="namespacedsp_1_1fft.html#ac9f6db704ad42fa5b125b8cde90f2603" title="Computes the inverse of rfft.">irfft()</a> <br /></td></tr>
<tr class="separator:af56643f8c6484395b2a70f0a4312476a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167c9e606b663c22f0f39e2296d1377b"><td class="memTemplParams" colspan="2"><a id="a167c9e606b663c22f0f39e2296d1377b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a167c9e606b663c22f0f39e2296d1377b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedsp_1_1fft.html#a167c9e606b663c22f0f39e2296d1377b">fftconvolution</a> (const std::vector&lt; T &gt; &amp;volume, const std::vector&lt; T &gt; &amp;kernel, convolution_mode mode=convolution_mode::valid)</td></tr>
<tr class="memdesc:a167c9e606b663c22f0f39e2296d1377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast convolution using the FFT. <br /></td></tr>
<tr class="separator:a167c9e606b663c22f0f39e2296d1377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fast Fourier Transformations. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acd4596e9d5c9bd56e8b10baf64c78b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4596e9d5c9bd56e8b10baf64c78b3c">&#9670;&nbsp;</a></span>cfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; T &gt; &gt; dsp::fft::cfft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite_x</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 1-D discrete Fourier Transform. </p>
<p>This function computes the 1-D n-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform(FFT) algorithm for complex input signals. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the complex values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Complex input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">overwrite_x</td><td>If true, the contents of x can be destroyed; the default is false. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="a40b408972cb96b687bd207fe14b341df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b408972cb96b687bd207fe14b341df">&#9670;&nbsp;</a></span>icfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; T &gt; &gt; dsp::fft::icfft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite_X</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 1-D inverse discrete Fourier Transform. </p>
<p>This function computes the inverse of the 1-D n-point discrete Fourier transform computed by fft. In other words, ifft(fft(x)) == x to within numerical accuracy. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the complex values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Complex input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">overwrite_X</td><td>If true, the contents of X can be destroyed; the default is false. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="ac9f6db704ad42fa5b125b8cde90f2603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f6db704ad42fa5b125b8cde90f2603">&#9670;&nbsp;</a></span>irfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; dsp::fft::irfft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite_X</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of rfft. </p>
<p>This function computes the inverse of the 1-D n-point discrete Fourier Transform of real input computed by rfft. In other words, irfft(rfft(x), x.size()) == x to within numerical accuracy. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the complex values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Complex input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">overwrite_X</td><td>If true, the contents of x can be destroyed; the default is false. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The backward-transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
<a id="a054d4669893e32e3b3162ca4e661ffca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054d4669893e32e3b3162ca4e661ffca">&#9670;&nbsp;</a></span>rfft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; T &gt; &gt; dsp::fft::rfft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#aadeffdb34ec53320437b1c6dd1354915">NormalizationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>NormalizationMode::backward</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite_x</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedsp_1_1fft.html#a4fef2564f82f5eb8ea2d5c9909fb2ba4">backend</a>&#160;</td>
          <td class="paramname"><em>backend</em> = <code>backend::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 1-D discrete Fourier Transform for real input. </p>
<p>This function computes the 1-D n-point discrete Fourier Transform (DFT) of a real-valued vector by means of an efficient algorithm called the Fast Fourier Transform (FFT). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the real values. Should be float, double or long double, other types will cause undefined behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Real input </td></tr>
    <tr><td class="paramname">n</td><td>Length of the transformed output. If n is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If n is 0 (default), the length of the input is used. </td></tr>
    <tr><td class="paramname">mode</td><td>The normalization mode: "backward" means normalization by n on the inverse transformation only, "forward" means on the forward transformation only, and "ortho" means divide by sqrt(n) in both directions. </td></tr>
    <tr><td class="paramname">overwrite_x</td><td>If true, the contents of x can be destroyed; the default is false. </td></tr>
    <tr><td class="paramname">backend</td><td>Can be automatic, simple, or fftw. 'simple' is a low-level straight-forward implementation of the complex FFT and 'fftw' uses the FFTW library. 'simple' is best for a small number fo samples due to the overhead of the FFTW planning stage. For longer inputs, FFTW becomes significantly faster. 'automatic' therefore chooses the 'simple' implementation for input lengths of less than 100 000 samples and 'fftw' for longer inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The forward-transformed truncated or zero-padded input. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedsp.html">dsp</a></li><li class="navelem"><a class="el" href="namespacedsp_1_1fft.html">fft</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
